<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="Zarduino" />
    <link rel="manifest" href="/site.webmanifest" />
    <title>Arduino 4WD Car Controller - Xbox Steering ‚ú®</title>
    <style>
        /* General styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
            transition: background-color 0.3s, color 0.3s; 
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 100%;
            transition: background-color 0.3s; 
        }

        h1 {
            text-align: center;
            margin-bottom: 20px; /* Adjusted margin */
            font-size: 2.2em; /* Adjusted size */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
         h2 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.5em;
            color: #f0f0f0;
        }


        .status-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Adjusted minmax */
            gap: 15px; /* Adjusted gap */
            margin-bottom: 25px; /* Adjusted margin */
        }

        .status-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 15px; /* Adjusted padding */
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: background-color 0.3s, border-color 0.3s;
        }

        .status-card h3 {
            margin-bottom: 8px; /* Adjusted margin */
            font-size: 1em; /* Adjusted font size */
            color: #fff; 
        }

        .status-value {
            font-size: 1.5em; /* Adjusted font size */
            font-weight: bold;
            color: #4CAF50; 
        }

        .control-section, .gemini-section {
            display: grid;
            grid-template-columns: 1fr; /* Default to 1 column */
            gap: 20px; /* Adjusted gap */
            margin-bottom: 25px; /* Adjusted margin */
        }
        
        /* Make control section 2 columns on wider screens */
        @media (min-width: 640px) {
            .control-section {
                grid-template-columns: 1fr 1fr;
            }
        }


        .bluetooth-controls, .car-controls, .gemini-controls {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px; /* Adjusted padding */
            transition: background-color 0.3s; 
        }

        .bluetooth-controls h3, .car-controls h3, .gemini-controls h3 {
            margin-bottom: 15px; /* Adjusted margin */
            text-align: center;
            color: #fff; 
            font-size: 1.2em;
        }

        .btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 10px 20px; /* Adjusted padding */
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px; /* Adjusted font size */
            margin: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover:not(:disabled) { /* Apply hover only if not disabled */
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            background: #555; /* Darker grey for disabled */
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn.danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }
        .btn.info {
             background: linear-gradient(45deg, #2196F3, #1976D2);
        }


        .directional-pad {
            display: grid;
            grid-template-areas: 
                ". up ."
                "left center right"
                ". down .";
            gap: 8px; /* Adjusted gap */
            max-width: 180px; /* Adjusted size */
            margin: 15px auto; /* Adjusted margin */
        }

        .directional-pad .btn {
            width: 50px; /* Adjusted size */
            height: 50px; /* Adjusted size */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px; /* Adjusted font size */
        }
        .btn-up { grid-area: up; }
        .btn-down { grid-area: down; }
        .btn-left { grid-area: left; } 
        .btn-right { grid-area: right; } 
        .btn-stop { 
            grid-area: center; 
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        .gamepad-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px; /* Adjusted padding */
            margin-top: 20px; /* Adjusted margin */
            text-align: center;
            transition: background-color 0.3s;
        }

        .gamepad-status {
            font-size: 1em; /* Adjusted font size */
            margin-bottom: 10px; /* Adjusted margin */
        }

        .gamepad-instructions {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 10px; /* Adjusted padding */
            margin-top: 10px; /* Adjusted margin */
            transition: background-color 0.3s;
        }

        .gamepad-instructions h4 {
            margin-bottom: 8px; /* Adjusted margin */
            color: #4CAF50; 
            font-size: 0.9em;
        }

        .gamepad-instructions ul {
            text-align: left;
            list-style: none;
            padding-left: 0;
            font-size: 0.85em;
        }

        .gamepad-instructions li {
            margin: 4px 0; /* Adjusted margin */
            padding-left: 18px; /* Adjusted padding */
            position: relative;
        }

        .gamepad-instructions li:before {
            content: "üéÆ";
            position: absolute;
            left: 0;
        }

        .connection-indicator {
            width: 10px; /* Adjusted size */
            height: 10px; /* Adjusted size */
            border-radius: 50%;
            background: #f44336; 
            display: inline-block;
            margin-left: 8px; /* Adjusted margin */
            animation: pulse 2s infinite;
        }

        .connection-indicator.connected {
            background: #4CAF50; 
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .dark-mode-toggle {
            position: fixed;
            top: 15px; /* Adjusted position */
            right: 15px; /* Adjusted position */
            z-index: 1000;
        }

        .dark-mode-toggle label {
            cursor: pointer;
            font-size: 22px; /* Adjusted size */
        }

        .dark-mode-toggle input[type="checkbox"] {
            display: none; 
        }
        
        body.dark-mode {
            background: #121212; /* Darker background for dark mode */
            color: #e0e0e0; 
        }

        body.dark-mode .container {
            background: rgba(30, 30, 30, 0.5); /* Darker container for dark mode */
            backdrop-filter: blur(8px); 
        }

        body.dark-mode .status-card {
            background: rgba(40, 40, 40, 0.7);
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        body.dark-mode .status-card h3 { color: #ccc; }
        body.dark-mode .status-value { color: #50fa7b; }

        body.dark-mode .bluetooth-controls, 
        body.dark-mode .car-controls,
        body.dark-mode .gemini-controls {
            background: rgba(35, 35, 35, 0.6);
        }
        body.dark-mode .bluetooth-controls h3, 
        body.dark-mode .car-controls h3,
        body.dark-mode .gemini-controls h3 { color: #ccc; }

        body.dark-mode .gamepad-info { background: rgba(35, 35, 35, 0.6); }
        body.dark-mode .gamepad-instructions { background: rgba(50, 50, 50, 0.5); }
        body.dark-mode .gamepad-instructions h4 { color: #50fa7b; }
        
        footer {
            text-align: center;
            padding: 15px; /* Adjusted padding */
            margin-top: auto; 
            width: 100%;
            color: white; 
            font-size: 0.85em; /* Adjusted font size */
        }
        body.dark-mode footer { color: #aaa; }

        /* Gemini Section Specifics */
        .gemini-controls textarea {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            background-color: rgba(255,255,255,0.1);
            color: white;
            min-height: 60px;
            margin-bottom: 10px;
            font-family: inherit;
            font-size: 0.9em;
        }
        body.dark-mode .gemini-controls textarea {
            border: 1px solid rgba(255,255,255,0.2);
            background-color: rgba(0,0,0,0.2);
            color: #e0e0e0;
        }
        .gemini-controls .output-area {
            background-color: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 8px;
            min-height: 40px;
            margin-top: 10px;
            white-space: pre-wrap; /* To show formatted command sequence */
            word-wrap: break-word;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
        }
         body.dark-mode .gemini-controls .output-area {
            background-color: rgba(0,0,0,0.4);
         }
        .loading-indicator {
            display: none; /* Hidden by default */
            text-align: center;
            margin: 10px 0;
            font-style: italic;
        }


        @media (max-width: 768px) {
            h1 { font-size: 2em; }
            .control-section, .gemini-section { grid-template-columns: 1fr; }
            .status-panel { grid-template-columns: 1fr; }
            .dark-mode-toggle { top: 10px; right: 10px; }
            .dark-mode-toggle label { font-size: 20px; }
        }
        @media (max-width: 480px) {
            h1 { font-size: 1.8em; }
            .container { padding: 20px; }
            .btn { padding: 8px 15px; font-size: 14px; }
            .directional-pad .btn { width: 45px; height: 45px; font-size: 16px; }
        }

    </style>
</head>
<body>
    <div class="dark-mode-toggle">
        <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
        <label for="darkModeToggle" id="darkModeEmoji">‚òÄÔ∏è</label>
    </div>

    <div class="container">
        <h1>üöó Arduino 4WD Car Controller</h1>
        <h2>Xbox Steering & Gemini Features ‚ú®</h2>
        
        <div class="status-panel">
            <div class="status-card">
                <h3>Bluetooth Status</h3>
                <div class="status-value" id="bluetoothStatus">
                    Disconnected <span class="connection-indicator" id="btIndicator"></span>
                </div>
            </div>
            <div class="status-card">
                <h3>Steering Angle</h3>
                <div class="status-value" id="angleValue">--¬∞</div>
            </div>
            <div class="status-card">
                <h3>Mode</h3>
                <div class="status-value" id="modeValue">Manual</div> 
            </div>
        </div>

        <div class="control-section">
            <div class="bluetooth-controls">
                <h3>üîó Connection</h3>
                <button class="btn" id="connectBtn" onclick="connectBluetooth()">Connect to Car</button>
                <button class="btn danger" id="disconnectBtn" onclick="disconnectBluetooth()" disabled>Disconnect</button>
            </div>

            <div class="car-controls">
                <h3>üïπÔ∏è Manual Controls (App)</h3>
                <div class="directional-pad">
                    <button class="btn btn-up" id="forwardBtn">‚Üë</button>
                    <button class="btn btn-left" id="leftBtnApp">‚Üê</button> 
                    <button class="btn btn-stop" id="stopBtn">‚èπ</button>
                    <button class="btn btn-right" id="rightBtnApp">‚Üí</button> 
                    <button class="btn btn-down" id="backwardBtn">‚Üì</button>
                </div>
                 <div style="text-align: center; margin-top: 10px;">
                    <button class="btn" onclick="centerSteering()">Center Steering (App)</button>
                </div>
            </div>
        </div>

        <div class="gemini-section">
            <div class="gemini-controls">
                <h3>Gemini Powered Features ‚ú®</h3>
                <div>
                    <h4>Generate Driving Command Sequence ‚ú®</h4>
                    <textarea id="drivingGoalInput" placeholder="e.g., Go forward a bit, turn right, and stop"></textarea>
                    <button class="btn info" id="generateSequenceBtn" onclick="generateDrivingSequence()">Generate Sequence</button>
                    <div class="loading-indicator" id="sequenceLoading">Generating sequence...</div>
                    <div id="commandSequenceOutput" class="output-area" style="display:none;"></div>
                    <button class="btn" id="executeSequenceBtn" onclick="executeGeneratedSequence()" style="display:none; margin-top:10px;">Execute Sequence</button>
                </div>
                <hr style="margin: 20px 0; border-color: rgba(255,255,255,0.2);">
                <div>
                    <h4>Get Car's Witty Status ‚ú®</h4>
                    <button class="btn info" id="wittyStatusBtn" onclick="getWittyStatus()">Ask Car for Status</button>
                    <div class="loading-indicator" id="statusLoading">Thinking of something witty...</div>
                </div>
            </div>
        </div>


        <div class="gamepad-info">
            <div class="gamepad-status" id="gamepadStatus">üéÆ Xbox Controller: Not Connected</div>
            <button class="btn" onclick="connectGamepad()">Connect Xbox Controller</button>
            
            <div class="gamepad-instructions">
                <h4>Xbox Controller Mapping:</h4>
                <ul>
                    <li><strong>App Buttons:</strong> Forward/Backward/Stop & App Steering</li>
                    <li><strong>Right Stick:</strong> Left/Right steering (Gamepad)</li>
                    <li><strong>A Button:</strong> Emergency Stop (Gamepad)</li>
                    <li><strong>X Button:</strong> Center Steering (Gamepad)</li>
                    <li><strong>Y Button:</strong> Connect/Disconnect Bluetooth (Gamepad)</li>
                </ul>
            </div>
        </div>
    </div>

    <footer>
        Made by Giscard
    </footer>

    <script>
        let bluetoothDevice = null;
        let bluetoothCharacteristic = null;
        let isConnected = false;
        let gamepadIndex = -1;
        let lastCommand = ''; // Stores the last single command sent (f, b, l, r, s, c)
        let isMoving = false; 
        let generatedCommandSequence = []; // To store sequence from Gemini

        // Gamepad state tracking
        let lastGamepadState = {
            rightStickX: 0, 
            buttons: {}
        };

        // DOM Elements
        const darkModeToggle = document.getElementById('darkModeToggle');
        const darkModeEmoji = document.getElementById('darkModeEmoji');
        const drivingGoalInput = document.getElementById('drivingGoalInput');
        const commandSequenceOutput = document.getElementById('commandSequenceOutput');
        const executeSequenceBtn = document.getElementById('executeSequenceBtn');
        const sequenceLoading = document.getElementById('sequenceLoading');
        const statusLoading = document.getElementById('statusLoading');
        const generateSequenceBtn = document.getElementById('generateSequenceBtn');
        const wittyStatusBtn = document.getElementById('wittyStatusBtn');


        function setDarkMode(isDark) {
            if (isDark) {
                document.body.classList.add('dark-mode');
                darkModeEmoji.textContent = 'üåô'; 
                localStorage.setItem('darkMode', 'enabled');
            } else {
                document.body.classList.remove('dark-mode');
                darkModeEmoji.textContent = '‚òÄÔ∏è'; 
                localStorage.setItem('darkMode', 'disabled');
            }
        }

        function toggleDarkMode() {
            setDarkMode(darkModeToggle.checked);
        }

        document.addEventListener('DOMContentLoaded', function() {
            const savedMode = localStorage.getItem('darkMode');
            if (savedMode === 'enabled') {
                darkModeToggle.checked = true;
                setDarkMode(true);
            } else {
                darkModeToggle.checked = false;
                setDarkMode(false);
            }
            setupManualControls(); 
            startGamepadPolling(); 
            updateModeDisplay(); 
        });

        function updateModeDisplay() {
            document.getElementById('modeValue').textContent = 'Manual';
        }

        async function connectBluetooth() {
            // Disable relevant buttons during connection attempt
            document.getElementById('connectBtn').disabled = true;
            wittyStatusBtn.disabled = true;
            generateSequenceBtn.disabled = true;

            try {
                console.log('Requesting Bluetooth Device...');
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [ 
                        { name: 'HC-06' },
                        { name: 'HC-05' },
                        { services: ['0000ffe0-0000-1000-8000-00805f9b34fb'] } 
                    ],
                    optionalServices: ['0000ffe0-0000-1000-8000-00805f9b34fb']
                });

                console.log('Connecting to GATT Server...');
                const server = await bluetoothDevice.gatt.connect();
                
                console.log('Getting Service...');
                const service = await server.getPrimaryService('0000ffe0-0000-1000-8000-00805f9b34fb');
                
                console.log('Getting Characteristic...');
                bluetoothCharacteristic = await service.getCharacteristic('0000ffe1-0000-1000-8000-00805f9b34fb');
                
                await bluetoothCharacteristic.startNotifications();
                bluetoothCharacteristic.addEventListener('characteristicvaluechanged', handleBluetoothData);
                
                isConnected = true;
                updateConnectionStatus();
                console.log('Connected successfully!');
                showCustomMessage('Bluetooth connected successfully!');
            } catch (error) {
                console.error('Bluetooth connection failed:', error);
                showCustomMessage('Bluetooth connection failed. Ensure car is on & discoverable.');
                isConnected = false; // Ensure isConnected is false on failure
                updateConnectionStatus(); // Update UI to reflect failure
            } finally {
                // Re-enable buttons based on connection status
                 document.getElementById('connectBtn').disabled = isConnected;
                 wittyStatusBtn.disabled = !isConnected;
                 generateSequenceBtn.disabled = !isConnected;
                 if(executeSequenceBtn) executeSequenceBtn.disabled = !isConnected || generatedCommandSequence.length === 0;
            }
        }

        async function disconnectBluetooth() {
            if (bluetoothDevice && bluetoothDevice.gatt.connected) {
                bluetoothDevice.gatt.disconnect();
            }
            isConnected = false;
            bluetoothDevice = null;
            bluetoothCharacteristic = null;
            updateConnectionStatus();
            console.log('Disconnected.');
            showCustomMessage('Bluetooth disconnected.');
        }

        function updateConnectionStatus() {
            const statusElement = document.getElementById('bluetoothStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            if (isConnected) {
                statusElement.innerHTML = 'Connected <span class="connection-indicator connected"></span>';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                wittyStatusBtn.disabled = false;
                generateSequenceBtn.disabled = false;
                if(executeSequenceBtn) executeSequenceBtn.disabled = generatedCommandSequence.length === 0;

            } else {
                statusElement.innerHTML = 'Disconnected <span class="connection-indicator"></span>';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                wittyStatusBtn.disabled = true;
                generateSequenceBtn.disabled = true;
                if(executeSequenceBtn) executeSequenceBtn.disabled = true;
            }
        }
        
        async function sendCommand(command) {
            if (!isConnected || !bluetoothCharacteristic) {
                console.log('Not connected to car, command not sent:', command);
                return;
            }
            try {
                const encoder = new TextEncoder();
                await bluetoothCharacteristic.writeValue(encoder.encode(command));
                console.log('Sent command:', command);
                lastCommand = command; // Update last single command
            } catch (error) {
                console.error('Error sending command:', error);
                showCustomMessage('Error sending command.');
            }
        }

        function handleBluetoothData(event) {
            const decoder = new TextDecoder();
            const data = decoder.decode(event.target.value);
            console.log('Received:', data); 
            
            if (data.startsWith('ANGLE:')) {
                const angle = parseInt(data.split(':')[1]);
                updateAngleDisplay(angle);
            }
        }

        function updateAngleDisplay(angle) {
            document.getElementById('angleValue').textContent = angle + '¬∞';
        }

        function setupManualControls() {
            const appMovementControls = {
                'forwardBtn': 'f',
                'backwardBtn': 'b',
                'stopBtn': 's' 
            };
            const appSteeringControls = {
                'leftBtnApp': 'l',
                'rightBtnApp': 'r'
            };

            Object.entries(appMovementControls).forEach(([btnId, command]) => {
                const btn = document.getElementById(btnId);
                if (!btn) { console.error("Button not found:", btnId); return; }

                const sendAndTrack = () => { if(isConnected) sendCommand(command); btn.style.transform = 'scale(0.95)'; isMoving = (command === 'f' || command === 'b'); };
                const resetStyle = () => { btn.style.transform = 'scale(1)';};

                btn.addEventListener('mousedown', sendAndTrack);
                btn.addEventListener('mouseup', resetStyle);
                btn.addEventListener('mouseleave', resetStyle); 
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); sendAndTrack(); });
                btn.addEventListener('touchend', (e) => { e.preventDefault(); resetStyle(); });
            });

            Object.entries(appSteeringControls).forEach(([btnId, command]) => {
                const btn = document.getElementById(btnId);
                 if (!btn) { console.error("Button not found:", btnId); return; }
                const sendSteering = () => { if(isConnected) sendCommand(command); btn.style.transform = 'scale(0.95)'; };
                const resetSteeringStyle = () => { btn.style.transform = 'scale(1)';};
                btn.addEventListener('mousedown', sendSteering);
                btn.addEventListener('mouseup', resetSteeringStyle);
                btn.addEventListener('mouseleave', resetSteeringStyle);
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); sendSteering(); });
                btn.addEventListener('touchend', (e) => { e.preventDefault(); resetSteeringStyle(); });
            });
        }
        
        function centerSteering() {
            if(isConnected) sendCommand('c'); 
            console.log("Center steering command ('c') sent via app button.");
        }

        function connectGamepad() {
            if (navigator.getGamepads) {
                window.addEventListener("gamepadconnected", (e) => {
                    console.log("Gamepad connected:", e.gamepad);
                    gamepadIndex = e.gamepad.index;
                    updateGamepadStatus(`üéÆ ${e.gamepad.id}: Connected`);
                });
                window.addEventListener("gamepaddisconnected", (e) => {
                    console.log("Gamepad disconnected:", e.gamepad);
                    if (e.gamepad.index === gamepadIndex) { 
                        gamepadIndex = -1;
                        updateGamepadStatus('üéÆ Xbox Controller: Not Connected');
                    }
                });
                const gamepads = navigator.getGamepads();
                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i]) {
                        gamepadIndex = gamepads[i].index;
                        updateGamepadStatus(`üéÆ ${gamepads[i].id}: Connected`);
                        break; 
                    }
                }
            } else {
                showCustomMessage('Gamepad API not supported in this browser.');
            }
        }

        function updateGamepadStatus(status) {
            document.getElementById('gamepadStatus').textContent = status;
        }

        function startGamepadPolling() {
            setInterval(pollGamepad, 50); 
        }

        function pollGamepad() {
            if (gamepadIndex === -1 || !isConnected) return;
            const gamepad = navigator.getGamepads()[gamepadIndex];
            if (!gamepad) return;
            const deadzone = 0.25;

            const rightStickX = gamepad.axes[2]; 
            if (Math.abs(rightStickX) > deadzone) {
                if (rightStickX > deadzone && lastGamepadState.rightStickX <= deadzone) sendCommand('r');
                else if (rightStickX < -deadzone && lastGamepadState.rightStickX >= -deadzone) sendCommand('l');
            }
            lastGamepadState.rightStickX = rightStickX;

            const buttons = gamepad.buttons;
            if (buttons[0] && buttons[0].pressed && (!lastGamepadState.buttons[0] || !lastGamepadState.buttons[0].pressed)) { sendCommand('s'); isMoving = false; console.log("Gamepad A: Stop"); }
            if (buttons[2] && buttons[2].pressed && (!lastGamepadState.buttons[2] || !lastGamepadState.buttons[2].pressed)) { sendCommand('c'); console.log("Gamepad X: Center"); }
            if (buttons[3] && buttons[3].pressed && (!lastGamepadState.buttons[3] || !lastGamepadState.buttons[3].pressed)) { if (isConnected) disconnectBluetooth(); else connectBluetooth(); console.log("Gamepad Y: BT Toggle");}

            lastGamepadState.buttons = {};
            buttons.forEach((button, index) => { lastGamepadState.buttons[index] = { pressed: button.pressed, value: button.value }; });
        }
        
        // --- Gemini API Features ---
        const GEMINI_API_KEY = ""; // Per instructions, leave empty. Handled by environment.
        const GEMINI_API_URL_FLASH = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

        async function callGeminiAPI(prompt) {
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }]
            };
            try {
                const response = await fetch(GEMINI_API_URL_FLASH, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorBody = await response.text();
                    console.error("Gemini API Error HTTP Status:", response.status, errorBody);
                    throw new Error(`Gemini API request failed with status ${response.status}`);
                }
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    console.error("Unexpected response structure from Gemini API:", result);
                    if (result.promptFeedback) {
                         console.error("Prompt Feedback:", result.promptFeedback);
                         if (result.promptFeedback.blockReason) {
                            return `Blocked: ${result.promptFeedback.blockReason}. Details: ${JSON.stringify(result.promptFeedback.safetyRatings)}`;
                         }
                    }
                    return "Sorry, I couldn't generate a response right now.";
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                return `Error: ${error.message}. Check console for details.`;
            }
        }

        async function generateDrivingSequence() {
            if (!isConnected) {
                showCustomMessage("Please connect to the car's Bluetooth first.");
                return;
            }
            const goal = drivingGoalInput.value.trim();
            if (!goal) {
                showCustomMessage("Please enter a driving goal.");
                return;
            }

            sequenceLoading.style.display = 'block';
            commandSequenceOutput.style.display = 'none';
            executeSequenceBtn.style.display = 'none';
            generateSequenceBtn.disabled = true;

            const prompt = `You are a command interpreter for a simple RC car. The car understands these single-character commands: 'f' (move forward one unit), 'b' (move backward one unit), 'l' (turn left slightly), 'r' (turn right slightly), 's' (stop motors).
Generate a comma-separated sequence of ONLY these commands to achieve the following goal: "${goal}".
The sequence should be reasonable for a toy car and not excessively long (aim for 5-15 commands if possible).
Example: For 'go in a small square and stop', you might generate 'f,f,r,f,f,r,f,f,r,f,f,s'.
Only output the comma-separated command string. Do not include any other text, explanations, or markdown.`;

            const sequenceText = await callGeminiAPI(prompt);
            
            sequenceLoading.style.display = 'none';
            generateSequenceBtn.disabled = false;

            if (sequenceText.startsWith("Error:") || sequenceText.startsWith("Blocked:") || sequenceText.startsWith("Sorry,")) {
                commandSequenceOutput.textContent = `Error generating sequence: ${sequenceText}`;
            } else {
                 // Validate and clean the sequence
                generatedCommandSequence = sequenceText.split(',')
                    .map(cmd => cmd.trim())
                    .filter(cmd => ['f', 'b', 'l', 'r', 's'].includes(cmd));
                
                if (generatedCommandSequence.length > 0) {
                    commandSequenceOutput.textContent = `Generated Sequence: ${generatedCommandSequence.join(', ')}`;
                    executeSequenceBtn.style.display = 'inline-block';
                    executeSequenceBtn.disabled = false;
                } else {
                    commandSequenceOutput.textContent = "Could not generate a valid command sequence from the response. Please try a different goal.";
                    generatedCommandSequence = []; // Clear any invalid sequence
                }
            }
            commandSequenceOutput.style.display = 'block';
        }

        async function executeGeneratedSequence() {
            if (!isConnected) {
                showCustomMessage("Not connected to car. Cannot execute sequence.");
                return;
            }
            if (generatedCommandSequence.length === 0) {
                showCustomMessage("No command sequence generated or sequence is empty.");
                return;
            }

            executeSequenceBtn.disabled = true;
            showCustomMessage(`Executing sequence: ${generatedCommandSequence.join(', ')}...`);

            for (let i = 0; i < generatedCommandSequence.length; i++) {
                const command = generatedCommandSequence[i];
                await sendCommand(command);
                // Add a small delay between commands to allow the car to react
                // Adjust delay as needed. 500ms for movement, 300ms for turns/stop
                let delay = (command === 'f' || command === 'b') ? 700 : 400;
                if (command === 's') delay = 200; 
                await new Promise(resolve => setTimeout(resolve, delay)); 
                
                // Safety stop if Bluetooth disconnects during sequence
                if (!isConnected) {
                    showCustomMessage("Bluetooth disconnected during sequence execution. Stopping.");
                    break;
                }
            }
            showCustomMessage("Sequence execution finished.");
            executeSequenceBtn.disabled = false;
        }

        async function getWittyStatus() {
            if (!isConnected) {
                showCustomMessage("Please connect to the car's Bluetooth first to get its status.");
                return;
            }
            statusLoading.style.display = 'block';
            wittyStatusBtn.disabled = true;

            const currentAngleText = document.getElementById('angleValue').textContent;
            const carAction = lastCommand ? `Last action: '${lastCommand}'` : "Idle"; // Use the last single command

            const prompt = `You are the quirky AI personality of a small, adventurous RC car.
Given the car's current status: "Action: ${carAction}, Steering Angle: ${currentAngleText}, Bluetooth: Connected",
generate a short, witty, and fun status update or thought from the car's perspective (max 1-2 sentences).
Be creative and a little humorous. For example, if idle, it might be dreaming of off-roading. If moving, it's on a grand mission.`;

            const wittyText = await callGeminiAPI(prompt);
            statusLoading.style.display = 'none';
            wittyStatusBtn.disabled = false;
            showCustomMessage(`Car says: "${wittyText}"`);
        }


        // Custom Message Modal (replaces alert)
        function showCustomMessage(message) {
            let modal = document.getElementById('customMessageModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'customMessageModal';
                Object.assign(modal.style, {
                    position: 'fixed', left: '0', top: '0', width: '100%', height: '100%',
                    backgroundColor: 'rgba(0,0,0,0.6)', display: 'flex',
                    justifyContent: 'center', alignItems: 'center', zIndex: '2000',
                    opacity: '0', transition: 'opacity 0.3s ease-in-out' // For fade effect
                });

                const modalContent = document.createElement('div');
                 Object.assign(modalContent.style, {
                    padding: '25px', borderRadius: '12px', textAlign: 'center',
                    boxShadow: '0 8px 25px rgba(0,0,0,0.3)', maxWidth: '90%',
                    transform: 'scale(0.9)', transition: 'transform 0.3s ease-in-out' // For pop effect
                });
                
                const messageText = document.createElement('p');
                messageText.id = 'customMessageText';
                Object.assign(messageText.style, { marginBottom: '20px', fontSize: '1.1em'});

                const closeButton = document.createElement('button');
                closeButton.textContent = 'OK';
                closeButton.className = 'btn'; 
                closeButton.onclick = function() { 
                    modal.style.opacity = '0';
                    modalContent.style.transform = 'scale(0.9)';
                    setTimeout(() => modal.style.display = 'none', 300);
                };

                modalContent.appendChild(messageText);
                modalContent.appendChild(closeButton);
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                 // Trigger reflow to apply initial transition state
                void modal.offsetWidth;
            }
            
            document.getElementById('customMessageText').textContent = message;
            modal.style.display = 'flex';
            // Update modal colors based on current theme for content and button
            const modalContent = modal.querySelector('div'); 
            const closeButton = modal.querySelector('button');
            const isDark = document.body.classList.contains('dark-mode');
            
            modalContent.style.background = isDark ? '#3a3a3a' : '#f0f0f0'; // Darker grey / Lighter grey
            modalContent.style.color = isDark ? '#e8e8e8' : '#222';
            closeButton.style.background = isDark ? 'linear-gradient(45deg, #007bff, #0056b3)' : 'linear-gradient(45deg, #5cb85c, #4cae4c)'; // Blue for dark, Green for light
            closeButton.style.color = 'white';


            // Animate in
            setTimeout(() => {
                modal.style.opacity = '1';
                modalContent.style.transform = 'scale(1)';
            }, 10);
        }

        connectGamepad(); 
        updateConnectionStatus(); // Initialize button states based on whether BT is connected from a previous session (though Web Bluetooth usually requires fresh connection)
    </script>
</body>
</html>
